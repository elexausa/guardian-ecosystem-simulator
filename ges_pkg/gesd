#!/usr/bin/env python
#
# Copyright (C) 2019 Elexa Consumer Product, Inc.
#
# This file is part of the Guardian Device Simulator
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import datetime
import threading
import socket, select
import time
import logging
import argparse
import json

import core
from devices import Valve

###################
## Configuration ##
###################

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='PID-%(process)d,THR-(%(threadName)-9s),%(levelname)s,%(asctime)s: %(message)s'
)

# Seed for random()
RANDOM_SEED = time.time()

# Networking
DEFAULT_IP = '127.0.0.1'
DEFAULT_PORT = 7700


##########################
## Configure argparsing ##
##########################

# Create parser
parser = argparse.ArgumentParser()

# Accept host address
parser.add_argument(
    '-ip',
    '--ip',
    nargs='?',
    const=DEFAULT_IP,
    default=DEFAULT_IP,
    help='Specify simulator host address. Defaults to %s.' % DEFAULT_IP
)

# Accept port
parser.add_argument(
    '-p',
    '--port',
    nargs='?',
    const=DEFAULT_PORT,
    default=DEFAULT_PORT,
    help='Specify simulator port. Defaults to %d.' % DEFAULT_PORT,
    type=int
)

class GES_Daemon(threading.Thread):
    BUFFER = 1024

    valves = {}

    for i in range(10):
        v = Valve()
        valves[v._instance_name] = v
        print(v.dump_json())

    def __init__(self, ip=DEFAULT_IP, port=DEFAULT_PORT):
        super().__init__()

        # Set name
        self.setName('ges-daemon')

        # Store server information
        self._ip = ip
        self._port = port

        # Create socket list
        self._socks = []
        # self._socks.append(s)

        # Create and store sockets
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # self._sock.setblocking(0)

        # Create killpill event
        self._kill_event = threading.Event()

        logging.info('GES daemon created!')

    def run_simulation(self):
        logging.info('run boy run')


        core.ENV.run()

    def kill(self):
        """Sets the internal killpill to halt the thread.
        """
        self._kill_event.set()

    def run(self):
        """Opens UDP and listens for commands.

        Opens a UDP socket on the provided IP and
        port and enables full control of simulation
        including but not limited to:
            - Device spawning
            - Change environment configuration
            - Start/stop simulation
        """
        # Bind socket
        self._sock.bind((self._ip, self._port))

        logging.info('GES daemon started on %s:%d...' % (self._ip, self._port))

        # Enter loop
        try:
            while True and not self._kill_event.is_set():
                logging.info('Waiting for packet...')

                # Wait for data
                data, clientaddr = self._sock.recvfrom(1024)

                # Data recieved, process
                logging.info('Packet received (%d bytes from %s:%d)' % (len(data), clientaddr[0], clientaddr[1]))

                # Receive and parse
                self.parse_packet(data)

        except Exception as e:
            # TODO: make this better
            # TODO: Ensure data persistance before killing

            # Something triggered shutdown
            logging.warn('GES daemon halted! Cause: %s' % e)

    def parse_packet(self, packet: bytearray):
        """Parses raw packet and runs relevant functionality.

        Args:
            packet (bytearray): Raw packet as bytearray
        """
        # Process packet
        try:
            # TODO: Implement some sort of authentication here?
            # TODO: Add a preprocessor to validate packet?

            # Attempt to decode and parse as JSON
            packet_json = json.loads(packet.decode('utf-8').replace("'", "\""))
        except Exception as e:
            # TODO: make this better (see https://docs.python.org/3/library/json.html#exceptions)
            # Log parse issue and ignore packet
            logging.warn('Error parsing packet! Cause: %s, Raw packet: %s' % (str(e), packet))
        else:
            # TODO: Good packet, handle it
            logging.info('Good packet received! \n%s' % json.dumps(packet_json, indent=4, sort_keys=True))

            if 'command' in packet_json:
                if packet_json['command'] == 'start':
                    logging.info('starting sim')
                    self.run_simulation()
                if packet_json['command'] == 'get_curr_time':
                    logging.info('current environment time: %d' % core.ENV.now)

if __name__ == "__main__":
    # Record start time
    starttime = datetime.datetime.now()

    # Parse incoming arguments
    args = parser.parse_args()

    # Store networking
    ip = args.ip
    port = args.port

    # Spawn instance
    daemon = GES_Daemon(ip, port)

    daemon.setDaemon(True)

    try:
        # Start and join
        daemon.start()
        daemon.join()

    except (KeyboardInterrupt, SystemExit):
        # Clean shutdown
        logging.warning('GES daemon shutting down...')

        # Send kill
        daemon.kill()

        # Calculate duration
        duration = round((datetime.datetime.now() - starttime).total_seconds())

        # Clean exit
        logging.info('Daemon exited. Total duration: %d seconds' % duration)