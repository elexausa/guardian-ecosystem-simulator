#!/usr/bin/env python
#
# Copyright (C) 2019 Elexa Consumer Product, Inc.
#
# This file is part of the Guardian Device Simulator
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import datetime
import time
import multiprocessing
import socket, select
import logging
import json
import argparse
import simpy
import random

from ges.core.util import response, const
from ges.core import communication
from ges.core import communicators
from ges.objects import Valve_Controller, Leak_Detector

###################
## Configuration ##
###################

# TODO: Move configuration out to config class - AB 03/12/2019

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s,%(asctime)s,%(process)d,%(threadName)s](%(filename)s/%(funcName)s): %(message)s',
    handlers=[
        logging.FileHandler(filename='history.log'),
        logging.StreamHandler()
    ]
)

# Seed for random()
RANDOM_SEED = time.time()

# Networking
DEFAULT_IP = '127.0.0.1'
DEFAULT_PORT = 7700

################
## Networking ##
################

# Create socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

##########################
## Configure argparsing ##
##########################

# Create parser
parser = argparse.ArgumentParser()

# Accept host address
parser.add_argument(
    '-ip',
    '--ip',
    nargs='?',
    const=DEFAULT_IP,
    default=DEFAULT_IP,
    help='Specify simulator host address. Defaults to %s.' % DEFAULT_IP
)

# Accept port
parser.add_argument(
    '-p',
    '--port',
    nargs='?',
    const=DEFAULT_PORT,
    default=DEFAULT_PORT,
    help='Specify simulator port. Defaults to %d.' % DEFAULT_PORT,
    type=int
)

###########################
## Simulation parameters ##
###########################

# Define environment
# env = simpy.Environment()
env = simpy.rt.RealtimeEnvironment()

# Create communication tunnels
rf_comm_tunnel = communicators.RF(env)
wan_comm_tunnel = communicators.WAN(env)
phys_comm_tunnel = communicators.Physical(env)

# Define list to store simulated object instances
objects = []

# Simulator process
process = None

def listen():
    """Listens for commands on UDP socket.

    Listens for incoming data on the UDP socket
    as commands and enables full control of
    simulation, including but not limited to:
        - Environment configuration
        - Device spawning
        - Start/stop simulation
    """
    while True:
        # Wait for data
        data, clientaddr = sock.recvfrom(4096)

        # Data recieved, process
        logging.info('packet received (%d bytes from %s:%d)' % (len(data), clientaddr[0], clientaddr[1]))

        # Receive and parse
        parse_packet(data, clientaddr)


def parse_packet(packet: bytearray, sender: tuple):
    """Parses raw packet and runs relevant functionality.

    Args:
        packet (bytearray): Raw packet as bytearray
        sender (tuple): Packet sender address and port
    """
    # Process packet
    try:
        # TODO: Implement some sort of authentication here?
        # TODO: Add a preprocessor to validate packet?
        global process

        # Attempt to decode and parse as JSON
        packet_json = json.loads(packet.decode('utf-8').replace("'", "\""))
    except Exception as e:
        # TODO: make this better (see https://docs.python.org/3/library/json.html#exceptions)
        # Log parse issue and ignore packet
        logging.warning('error parsing packet! Cause: %s, Raw packet: %s' % (str(e), packet))
    else:
        logging.info('packet received: %s' % packet_json)

        # TODO: Clean up this command handling

        if 'command' in packet_json:
            command = packet_json['command']

            if command == 'pair_leak_detector':
                # Initial
                parent_uuid = None
                child_uuid = None
                parent_obj = None
                child_obj = None

                # Get from command
                if 'parent_uuid' in packet_json:
                    parent_uuid = packet_json['parent_uuid']
                if 'child_uuid' in packet_json:
                    child_uuid = packet_json['child_uuid']

                # Find parent and child
                for obj in objects:
                    if isinstance(obj, Valve_Controller):
                        if obj.metadata['mac_address'] == parent_uuid:
                            parent_obj = obj
                    elif isinstance(obj, Leak_Detector):
                        if obj.metadata['mac_address'] == child_uuid:
                            child_obj = obj

                error_codes = []

                # "Pair"
                if parent_obj is None or child_obj is None:
                    error_codes.append(response.Error.DOES_NOT_EXIST)
                else:
                    parent_obj.leak_detectors.append(child_obj)

                # Save parent if sim is running
                if isinstance(process, multiprocessing.Process) and process.is_alive():
                    parent_obj.sync_to_db()

                # Create response
                res = response.construct_response(error_codes=error_codes)

                logging.info('sending response: {}'.format(res))

                # Return response
                sock.sendto(json.dumps(res).encode(), sender)

            if command == 'spawn_valve_controller':
                # Defaults
                count = 1

                # Optionals
                if 'count' in packet_json:
                    count = packet_json['count']
                    if count > 100: count = 100

                # Spawn objects
                valve_controllers = [Valve_Controller(env=env, comm_tunnels=[rf_comm_tunnel, wan_comm_tunnel, phys_comm_tunnel]) for _ in range(count)]

                # Add to objects
                objects.extend(valve_controllers)

                rdata = {}
                for vc in valve_controllers:
                    rdata[vc._metadata.serial_number] = vc._metadata.mac_address

                # Create response
                res = response.construct_response(data=rdata)

                logging.info('sending response: {}'.format(res))

                # Return response
                sock.sendto(json.dumps(res).encode(), sender)

            if command == 'spawn_leak_detector':
                # Defaults
                count = 1

                # Optionals
                if 'count' in packet_json:
                    count = packet_json['count']
                    if count > 100: count = 100

                # Spawn objects
                leak_detectors = [Leak_Detector(env=env, comm_tunnels=[rf_comm_tunnel, wan_comm_tunnel, phys_comm_tunnel]) for _ in range(count)]

                # Add to objects
                objects.extend(leak_detectors)

                rdata = {}
                for ld in leak_detectors:
                    rdata[ld._metadata.serial_number] = ld._metadata.mac_address

                # Create response
                res = response.construct_response(data=rdata)

                logging.info('sending response: {}'.format(res))

                # Return response
                sock.sendto(json.dumps(res).encode(), sender)

            if command == 'run':
                # Defaults for optional parameters
                time = None

                # Return information
                rdata = {
                    'started_at': datetime.datetime.now().isoformat(),
                    'time': -1 # represents no time limit
                }
                error_codes = []

                logging.info('starting simulation...')

                if 'time' in packet_json:
                    time = int(packet_json['time'])
                    rdata['time'] = time

                # Already running
                if isinstance(process, multiprocessing.Process) and process.is_alive():
                    logging.warning('simulation already running')
                    error_codes.append(response.Error.SIMULATION_RUNNING)

                # Create process
                # TODO: Add 'breakpoint' support for pausing simulation upon event occurance
                process = SimulationRunner(time=time)

                # Start 'er up
                process.start()

                logging.info('started!')

                # Create default response
                res = response.construct_response(data=rdata, error_codes=error_codes)

                logging.info('sending response: {}'.format(res))

                # Return response
                sock.sendto(json.dumps(res).encode(), sender)

            if command == 'kill':
                if isinstance(process, multiprocessing.Process) and process.is_alive():
                    process.terminate()
                    logging.warning('simulation terminated')
                else:
                    logging.info('simulation not running')


class SimulationRunner(multiprocessing.Process):
    def __init__(self, time=None):
        super().__init__(name='ges-proc-wrapper')
        self._end_time = time

    def run(self):
        # Sync environment
        env.sync()

        logging.info('resynced environment with current time')

        # Run
        if self._end_time is None:
            logging.warning('running killed or out of events...')
            env.run()
        elif isinstance(self._end_time, int):
            logging.warning('running for {} seconds)...'.format(self._end_time))
            env.run(until=self._end_time)

        logging.info('simulation complete')

if __name__ == "__main__":
    # Record start time
    starttime = datetime.datetime.now()

    # Parse incoming arguments
    args = parser.parse_args()

    # Store networking config
    ip = args.ip
    port = args.port

    # Bind socket
    sock.bind((ip, port))

    try:
        # Run the thing
        logging.info('waiting for packet...')

        # Start listener
        listen()
    except Exception as e:
        # Clean shutdown
        logging.warning('shutting down (reason: {})...'.format(str(e)))

        # Calculate duration
        duration = round((datetime.datetime.now() - starttime).total_seconds())

        # Clean exit
        logging.info('exited. Total duration: %d seconds' % duration)